#!/usr/bin/env bash
echo "load gitbash!"

# 
# git alias
# start working

echo $0 loaded!
# export GIT_TRACE=1
# export GIT_TRANSFER_TRACE=1
# export GIT_CURL_VERBOSE=1

function cgit() {
    if [[ ! -d $1 ]];then
        echo "first input must be dir path."
        return 1
    fi
    git -C $@
}

function xg() {
    if [[ ! -d $1 ]];then
        cgit $(pwd) ${*}
    else
        cgit $1 ${@:2}
    fi
}

function SetGitTrace() {
    if [[ -z $1 || $1 == '0' ]];then
        unset GIT_TRACE
        unset GIT_TRANSFER_TRACE
    else
        export GIT_TRACE=1
        export GIT_TRANSFER_TRACE=1
    fi
}

function SetGitVerbose() {
    if [[ -z $1 || $1 == '0' ]];then
        unset GIT_CURL_VERBOSE
    else
        export GIT_CURL_VERBOSE=1   
    fi
}


# alias clone="git clone"
function clone() {
    xg $1 clone ${@:2}
    gen_git_hooks
}

# alias init="git init"
function init() {
    xg $1 init ${@:2}
    gen_git_hooks
}

function gen_git_hooks() {
    if [[ ! -f .git/hooks/post-checkout ]];then
        echo 
'echo "checked out"
echo $pwd
if [[ -f ./Podfile && -f $(which pod) ]];then
    pod install
fi
' > .git/hooks/post-checkout
    fi

    
}

# working on the current change
function add() {
    xg $1 add ${@:2}
}

function reset() {
    xg $1 reset ${@:2}
}

function grm() {
    xg $1 rm ${@:2}
}

function gmv() {
    xg $1 mv ${@:2}
}

# examine the history and state

function bisect() {
    xg $1 bisect ${@:2}
}

function log() {
    xg $1 log ${@:2}
}

function gitgrep() {
    xg $1 grep ${@:2}
}

function show() {
    xg $1 show ${@:2}
}

# grow mark and tweak your commit history
function br() {
    xg $1 branch ${@:2}
}

function brl() {
    xg $1 branch --list ${@:2}
}

# sync repostory

function br_curr() {
	xg $1 branch --show-current ${@:2}
}

function pull_curr() {
    remote="origin"
    if [[ -z $1 ]];then
        echo "push_curr use default remote: \"origin\""
    else
        remote=$1
    fi

    brname=$(xg branch --show-current $@)
    xg $1 pull $remote $brname ${@:2} && clear
    #git pull $remote $(git branch --show-current) && clear
}

function push_curr {
    remote="origin"
    if [[ -z $1 ]];then
        echo "push_curr use default remote: \"origin\""
    else
        remote=$1
    fi
    brname=$(xg branch --show-current $@)
    xg $1 push -u $remote $brname ${@:2} && clear

    # git push -u $remote $(git branch --show-current) && clear
}

function fetch_all() {
    remote="origin"
    if [[ -z $1 ]];then
        echo "push_curr use default remote: \"origin\""
    else
        remote=$1
    fi
    # brname=$(xg branch --show-current $@)

    xg $1 fetch $remote -a ${@:2} && clear
}

function gdiff() {
    xg $1 diff ${@:2}
}

function merge() {
    xg $1 merge ${@:2}
}

function rebase() {
    xg $1 rebase ${@:2}
}

function tag() {
    xg $1 tag ${@:2}
}

function clean() {
    xg $1 clean ${@:2}
}

# collabrate
function gfetch() {
    # conflict with google depo_tools 
    xg $1 fetch ${@:2}
}

function pull() {
    xg $1 pull ${@:2}
}

function push() {
    xg $1 push ${@:2}
}

# others
function stashl() {
    xg $1 stash list ${@:2}
}

function stash() {
    xg $1 stash ${@:2}
}

function remote() {
    xg $1 remote ${@:2}
}

# git utilities

# alias cleangit="git reset --hard && git clean -df"
function cleangit() {
    xg $1 reset --hard ${@:2}
    xg $1 clean -df ${@:2}
}

# alias adda="git add --all"
function adda() {
    xg $1 add --all ${@:2}
}

# alias addc="git add --all && git commit"
function addc() {
    xg $1 add --all ${@:2}
    xg $1 commit ${@:2}
}

# alias addca="git add --all && git commit --amend"
function addca() {
    xg $1 add --all ${@:2}
    xg $1 commit --amend ${@:2}
}

# alias logg="git log --graph"
function logg() {
    xg $1 log --graph ${@:2}
}

# alias logo="git log --oneline"
function logo() {
    xg $1 log --oneline ${@:2}
}

# alias loggo="git log --graph --oneline"
function loggo() {
    xg $1 log --graph --oneline ${@:2}
}

# alias logflw="git log --follow"
function logflow() {
    xg $1 log --follow ${@:2}
}

# alias reflog="git reflog"
function reflog() {
    xg $1 reflog ${@:2}
}

# alias worktree="git worktree"
function worktree() {
    xg $1 worktree ${@:2}
}

function difile() {
    br1=$1
    br2=$2
    file=$3
    if [[ -z $br1 || -z $br2 || -z $file ]];then
        echo "Please input branch1 branch2 and last filen name"
        echo "difile commit1 commit2 filename"
        echo "difile branch1 branc2 filename"
        return 1
    fi
    git diff $br1 $br2 $(find . -name $3)
}

# git checkout
function co() {
    xg $1 checkout ${@:2}
}

# git commit ...

function commit() {
    xg $1 commit ${@:2}
}

function cia() {
    xg $1 commit -a ${@:2}
}

function ciempty() {
    xg $1 commit --allow-empty ${@:2}
}

function ciam() {
    xg $1 commit --amend ${@:2}
}

function ci_() {
    if [[ -z $1 ]];then
        echo "Comments should not be empty."
        return 1
    fi
    git commit -m "${1} : "$2 ${@:3}    
}

function ci_mt() {
    local supported="Add Update Fix Optim Pack Note Remove"
    local e=""
    for e in supported;do
        if [[ $e == $1 ]];then
            break
        else
            e=""
        fi
    done

    if [[ -z $e ]];then
        echo "Fist input must be: $supported"
        return 1
    fi

    if [[ -z $2 && $1 != "Pack" ]];then
        echo "Comments should not be empty."
        return 1
    fi

    if [[ $1 == "*Pack" ]];then
        git commit -m "【$1】*pack" 
    else
        git commit -m "【${1}】"$2 ${@:3}
    fi
}

function ci_add() {
    if [[ -z $1 ]];then
        echo "Comments should not be empty."
        return 1
    fi
    git commit -m "【add】"$1 ${@:2}
}

function ci_update() {
    if [[ -z $1 ]];then
        echo "Comments should not be empty."
        return 1
    fi

    git commit -m "【update】"$1 ${@:2}
}

function ci_fix() {
    if [[ -z $1 ]];then
        echo "Comments should not be empty."
        return 1
    fi
    git commit -m "【fix】"$1  ${@:2}
}

# abbreviate for svn users.

function ci() {
    xg $1 commit ${@:2}
}

function st() {
    xg $1 status ${@:2}
}

function up() {
    xg $1 up ${@:2}
}

function di() {
    xg $1 diff ${@:2}
}

function wk() {
    xg $1 worktree ${@:2}
}

# git lfs command alias

function lfs() {
    xg $1 lfs ${@:2}
}

if [[ ! -f $(which git-lfs) ]];then
    echo "git-lfs not be installed."
    echo "Please visit site: https://git-lfs.github.com/"
else
    echo "git-lfs has been installed."
    echo "you can use "lfs pull" instead of "git lfs pull""
fi

function new_git_alias() {
    echo "new_gitc_alias()"
    echo "usage:"
    echo "new_gitc_alias Sub-name Some-repo-path"

    if [[ -z $1 ]];then
        echo "Please input git -C alias sub name"
        return 1
    fi

    if [[ ! -d $2 ]];then
        echo "Please input git -C home dir"
        return 1
    fi


    aname=$1
    home_dir=$2

    alias git_"$aname"='git -C $home_dir'
    alias log_"$aname"='git -C $home_dir log'
    alias co_"$aname"='git -C $home_dir checkout'
    alias di_"$aname"='git -C $home_dir diff'
    alias push_"$aname"='git -C $home_dir push'
    alias pull_"$aname"='git -C $home_dir pull'
    alias fetch_"$aname"='git -C $home_dir fetch'
    alias remote_"$aname"='git -C $home_dir remote'

    echo "create git command: git_$aname"
    echo "create git command: log_$aname"
    echo "create git command: co_$aname"
    echo "create git command: di_$aname"
    echo "create git command: push_$aname"
    echo "create git command: pull_$aname"
    echo "create git command: fetch_$aname"
    echo "create git command: remote_$aname"
}

function unalias_git() {
    if [[ -z $1 ]];then
        echo "Please input git -C alias sub name"
        return 1
    fi
    aname=$1
    unalias git_"$aname"
    unalias log_"$aname"
    unalias co_"$aname"
    unalias di_"$aname"
    unalias push_"$aname"
    unalias pull_"$aname"
    unalias fetch_"$aname"
    unalias remote_"$aname"

    echo "remove git command: git_$aname"
    echo "remove git command: log_$aname"
    echo "remove git command: co_$aname"
    echo "remove git command: di_$aname"
    echo "remove git command: push_$aname"
    echo "remove git command: pull_$aname"
    echo "remove git command: fetch_$aname"
    echo "remove git command: remote_$aname"
}

# fetch repository and remote 
function fr()
{
    # fetch repo
	# echo "fetch project $1"
    repo_path=$1
    if [[ -z $repo_path ]];then
        echo "Please input git repo path."
        return 1
    elif [[ ! -d $repo_path  ]];then
        echo "$repo_path does not exist."
        return 1
    fi

    remote_name="origin"
    if [[ -z $2 ]];then
        echo "use origin as default remote name."
    elif [[ -z $(git -C $repo_path remote show | grep $2) ]];then
        echo "remote $2 not exist."
        return 1
    fi
		echo remote_name: $remote_name
    # remote_name=$(git -C $repo_path remote show | grep $2)

    echo "begin:$repo_path"
    #echo git -C $repo_path fetch $remote_name -a
    git -C $repo_path fetch $remote_name -a
    echo "finsihed"
}

# fetch all repos in current path
function frall() {
    if [[ -z $1 ]];then
        echo "Please input git repo path."
        return 1
    elif [[ ! -d $1  ]];then
        echo "$1 does not exist."
        return 1
    fi
    projDir=$1
    for repo in $(find $projDir -name *.git | sed "s/.git//g"); do
		echo "fr $repo"
		fr $repo; 
	done
}

# use make push git repo
function gmake() {
	[ ! -d $HOME/.xcompile ] && git clone https://gitee.com/dehengxu/xcompile.git $HOME/.xcompile
	make -f $HOME/.xcompile/makefiles/makefile_git $1
}
